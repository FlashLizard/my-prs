# my-prs

## 说明

对论文PRS-Net的复现, 原文地址<https://arxiv.org/abs/1910.06511>
这是一个自监督的模型, 用于预测3d模型的对称平面和对称轴

## 如何运行

1. 下载shapenetcore.v2数据集, 并解压到data_handle/obj-data下. 也可以是其他的obj文件. obj-data内部的文件结构不影响对数据的处理
2. 进入data_handle目录, 运行`python data_process.py`处理数据:
   1. 此处使用open3d处理数据
   2. open3d使用扩展名来判断图片类型, 而shapenet数据集中有些图片的扩展名是jpg, 但实际是png, 若没有对这数据进行清洗, 可以运行时加上`--auto_rerun True`参数, 会自动清洗此类数据并重新运行
   3. 默认一种类型的obj不会处理超过128个, (此处做法对一个文件夹下的文件的读取控制在128个以内), 若要改变, 加上参数`--max_in_folder 1024`
   4. 处理时会对数据进行随机旋转
   5. 处理时可以加上`--show True`参数, 会不断地显示处理后的数据, 直到某次询问是否要继续时键入了n
3. 在根目录下运行`python train.py`进行训练:
   1. 如果中断了可以加上`begin_epoch`参数, 从指定的epoch开始训练
   2. 模型保存在`trained_model`目录下
4. 在根目录下运行`python test_xxx.py`进行测试, 可视化显示结果
   1. 每次测试时需要加上`--path 路径`参数, 指定待测试的模型路径
   2. 可以用`--data_path 路径`来指定用于测试的数据集路径, 默认为`data_handle/results/output0.npz`
   3. test_plane1.py: 显示三个平面
   4. test_plane2.py: 显示一个平面, 并显示对称点和对称后的距离差(4次方)
   5. test_quad1.py: 显示三根旋转轴
   6. test_quad2.py: 显示一根旋转轴, 并显示绕其旋转90°后的点和旋转后的距离差(4次方)

## 想法与经验

1. 使用jupyter进行调试, 方便重复运行某一段代码并查看内容
2. 计算损失的mask用于过滤对称点刚好在某个体素内的情况, 因为这种情况可以默认是重合的, 对损失贡献比较小, 可以忽略
3. 由于设备性能有限, 所以适当的减少了数据量, 并在处理shapenet数据集时避免了某一类模型占比太多
4. 尽量统一通conda来管理(或pip), 否则可能出问题
5. 不要把narray的list直接转为tensor, 会很慢, 应先使用np.stack把list转为narray, 再用torch.from_numpy转为tensor
6. 数据有问题, 使用open3d会出现jpg读取错误(后缀应该是png才对), 写了个自动清洗数据并自动重启
7. 模型中使用nn.ModuleList, 不要使用list存layer
8. 计算loss时，把距离的平方换为了距离的四次方，使其对于距离更敏感
9. 合理调整正则化项和近似距离差的比重
10. 将CNN层进行替换?
11. 考虑到对称轴或者对称点一定在重心上, 或许可以考虑去掉平面的D项, 而使其一定过重心, 对于对称轴同理, 虽然原本对于对称轴的处理似乎就是过原点进行旋转
12. 对称轴的loss可以再多加上几个旋转角度的距离差
13. 通过输出对称轴以及对称平面的参数发现很大, 如果太大那么参数更新时的变化可能很小, 不利于收敛, 所以可以考虑在损失中加入参数的正则化项防止参数变得过大(但好像会震荡)
14. 是否要把对称轴和对称平面的CNN分开训练, 因为两个需要的特征不一定一样